Java is a programming language.

a. What do you mean by programming language?

 Instructions-> Program -> Software  -> Software suit

  c++, python, javascript, c#, kotlin, ruby, swift, R, ?
 
   JAVA

JAVA -> Java is an high level object oriented programming language.

What are types of softwares?

1. System Softwares -  run your systems/computer  e.g. Operating systems, drivers . deals with hardware  - low level languages ex. C, c++
2. Application Softwares  - run on your system..  ex. browsers, office,  -> high level languages -> java, c#, python,


History of java ->  

Sun Microsystems -> 
1991 -> Embedded devices -> televisions, set top boxes

Green Team -> 1. James Gossling   2. Mike Sheridon   3. Patrick Noughton

OAK -> 

JAVA -> 1995 -> internet applications

JAVA -> Just Another Virtual Accelator

C++ -  object oriented programming language

1. Why java?

Features of JAVA (Buzzwords) ->  


1. Simple  -> c / c++ 
                c    ->  Dennis Ritchie
           ->  c++   ->  Bjarne Strusstrup

            
2. Object Oriented Programmimg language .
    Simula67 ->  First Object Oriented Programming Language

   Purely OOP-> Nothing in java that is not an object  / Everything in java is an object

3. Robust  ->   it does not allow you to make mistakes
                a. Memory management
                b. Exception handling
                c. Strongly typed language

4. Secure -> java programs run under its own environment  (JRE)

             JDK - Java Development Kit  - to develop and run apllications -> jdk 1.8
             JVM - Java Virtual Machine -> execute the application
             JRE - Java Runtime Environment -   to run applications

5. Architecture Neutral -> write  once, run anywhere, anytime, forever
                            JVM -> 
                             bytecode  ->  

6. Platform independant 

7. Distributed ->  RMI -> Remote Method Invocation

8. Compiled and interpreted  ->   source code -> object code
                                  1. javac -  source code ->  bytecode 
                                  2. java -  bytecode -> execuatable code

               bytecode -> a highly optimized set of instructions which is platform independant to be run by jvm

                    a.java  ->  compiler(javac)  -> a.class  -> interpreter(java)   ->  a.exe

9. Multithreaded  ->   

10. Dynamic -> 

           


Workspace - our own directory where we will store our work


class HelloWorld
{
   public static void main(String args[])
   {
       System.out.println("Hello!!! Welcome to Java");   
   }
}    


main()

- main() is only compulsory method in java
- Program execution always starts with main
- Progam ends at main


System.out  ->  output stream which represents a standard o/p device



Java Tokens ->   smallest individual parts of a program

1. datatypes ->   type of data that a variable can hold

                  Numbers  ->   
                     1. Integers (numbers without fraction point)
                             a. byte    -   1 byte     -    
                             b. short   -   2 bytes
                             c. int     -   4 bytes
                             d. long    -   8 bytes

                         0000 0000     -         1   1  1  1 1 1 1 1
                                                128 64 32 16 8 4 2 1


                     2. Floating  (numbers with fraction point)
                             a. float   - 4 bytes
                             b. double  - 8 bytes
 
                 Boolean -> true/false
                          a. boolean

                Characters  ->   unicode characters
                          a. char   -  2 bytes

1. Java is strongly typed language  ->
   - Evry type in java is strictly defined
   - every expression in java has a type

              int a= 10+10.5;
2. varible -> 

        1. First declare a variable then use it
        2. you can declare a variable anywhere
                    
                    byte a=129; // not possible

3. Identifiers ->  names given to programming elements(variable, constant, method, class, interface) by user

    Rules for identifiers ->
      1. you can use alphabets(a to z, A to Z), numbers, _
      2. you should not start with a number
      3. you can not use any other special character other than _
      4. you can not use keywords as identifiers
      5. java is case sensitive language


     ex->   abc   -  valid
            abc123  -  valid
            abc 123 -  invalid
            a_1   -  valid
            1_a  - invalid
            public  -  invalid
            Public  -   valid  
            ABCXYZ  -  valid
           
              void getStudents()
              {
              }
                  
4. Keywords -> names given by a language 

Swapping values of two numbers ->  using third variable and without using third variable


Read ->   Class Diagrams   ->

           System



How to read input from user?

1. Command Line Arguments ->    these are arguments which are passed to main() at the time of running a program

                                  public static void main(String args[])   args=[10,20]
                                  {
                                     System.out.println(args[1]);
                                  }
                                they are received in args[] 

                                javac Addition.java
                                java Addition 
                                java Addition 10 20
2. Standard objects ->   BufferedReader   Scanner 

                 System.in   -> standard input device  -  keyboard


Control Structures ->    if , if -else, while, do-while, for, switch

  1. Selection statements  -> if, if-else, switch
  2. iterative Statements -> while, do-while, for

  1. if & if-else

          if(condition)
          {
          }
          else
          {
          }

  1. program to check for even or odd 
  2. program to find maximum of two numbers
  3. program to find maximum of three numbers




2. While  -> iterative statement



while(condition)
{


}


1. print my name 10 times on screen
2. print 1 to 100 numbers on screen
3. print only even numbers between 1 to 100 on screen
4. calculate factorial of a number
5. print table of a number on screen

1	2	3	4					10
2	4	6	8
3	6	9	12
4	8	12	15
5
6
7
8
9
10	20	30	40					10


int i=1;
while(i<=10)
{
    int j=1;
    while(j<=10)
    {
       System.out.print((i*j)+"\t");
       j++;
    }
   i++;
System.out.println("");
}


-> POC  (Proof of Concepts)  ->  Operators in java

Arithmetic    Relational     Logical     Bitwise   Assignment  others
                               &  &&	 &
			       |  ||	 |

		boolean	    boolean      numbers   

   2 | 3
   true |  false
   true || false

   &&   ||   -> short circuit operators


				||		&&
    true  	true		true		true
	
    true	false		true		false

    false	true		true		false

    false	false		false		false


   (condition1)   ||  (condition2)    =>   true


   int number=27;
   System.out.println(number>>2)   




1. To check for prime number
2. Reverse a number
3. to check for palindrome number
4. to calculate sum of digits of a number
5. to check for armstrong number
6. to check for perfect number   ->   6      ->  1 2 3  ->  1 +2 +3  =>   6



=> switch ->   switch(expression)
               {
                   case value1: 
                  
                   case value2: 

                   case value3:   System.out.println("Valid for 1 2 3");
                                  break;

                   case value4:  System.out.println("Valid for 4 only");
                  
                    case value5:  System.out.println("Valid for 5 only");

                   default:
                   
               }


       
1. Read a month number and print which season this month belongs  -

            12  ->  Winter
             1  -> Winter
             5   -> Summer
          20  ->  please enter valid month number


2. Read a day number of a week and print that day

            1  ->  its Sunday
            2  ->  its Monday

            7 -> its Saturday

            10  -> please enter valid day number



----> Debugging   ->    finding and fixing bugs   .     To understand flow of execution of code

int i=1;
while(i<10)
{
   System.out.println(i);
   i++;
}

--> for  ->


   for(; condition;incer/decr)
   {
   }


->  1. Print all prime numbers between 1 to 50


2
3	5
7	11	13
17	19	23	29
31	37	39	41	47


->   Java is robust   ->    1. Strong memory management techniques
                            2. Strong exception handling mechanism
                            3. Java is strongly typed language
                                - every variable/expression has a datatype
                                - all types are strictly defined

                 1. Java allows automatic type conversion  ->   Implicit typecasting

                            a. Types of both variables or values must be compatible with each other
                                   all number datatypes are compatible with each other
                                       (byte,short, int, long, float, double)
                            b. destination type must be larger than source type

             2. explicit type casting -> 
                             Types of both variables or values must be compatible with each other
                                   all number datatypes are compatible with each other
                                       (byte,short, int, long, float, double)


 
 -->>>   Java is purely object oriented programming language

                - everything in java is an object


 Wrapper classes  ->  To represent normal built in type values as an object  ->  Wrapper classes

                       byte   -  Byte
                       short  -  Short
                       int    -  Integer
                       long   -  Long
                       float  -  Float
                       double -  Double
                       char   -  Character
                       boolean - Boolean

    Autoboxing  ->  representing a normal data type value as an object



--->  Arrays  ->    collection of similar datatype values  ->    consistancy
                    fix number of values
                    requires contigous memory block
 
      array     12 23 45 56 67 

              index ->   0   

        1. declare an array
        2. allocate memory to array

           int array[5];
           cout<<array[0];
            
           int array[];
           array=new int[10];

           int array[]=new int[10];       [0,0,0,0,0,0,0,0,0,0]
           sysout(array[0]);  // 0
           array[0]=10;                    [10,0,0,0,0,0,0,0,0,0]
           array[9]=20;                    [10,0,0,0,0,0,0,0,0,20]




1.  Read an array of n integers and calculate sum of all elements of an array. Accept values of array from user
1.  Read an array of n integers and find maximum of an array. Accept values of array from user.





[1,2,3,4,5]  =>  [1,4,9,16,25]
[-5,-4,-3,-2,-1]  =>  [1,4,9,16,25]
[-5,-3,1,2,4]  => [1,4,9,16,25]


-----------> String in java  ->


   1. String  ->  immutable   -> can not change contents
   2. StringBuffer  -> mutable  ->  can be modified   -> Thread safe
   3. StringBuilder  ->  mutable  ->  can be modified   -> not thread safe

String pool / String constant pool   ->   



String s1="hello"+


------------------> Stream -> a sequence of bytes which is attached to i/p or o/p devices 


1.InputStream
2.OutputStream
3.Reader
4.Writer


1. FileInputStream / FileOutputStream  ->


=> java code to calculate number of characters, words and lines in a file


Simula67 -> 

Object Oriented JAVA  ->   

1. Object ->  It is real world entity having some attributes and some behaviour.
              Physical entity  -> memory is allocated to it.
              instance of class

              ex. bajajFan  ->  1080rph, 1kg, 3, green, c123, bajaj, 5000, 4500rs
                       ->  
                  Laptop  ->  price, brand, processor, memory, camera, typeofbody, size, typeofscreen
                          -> playMusic(), watchMovies(), playGames(), coding(), storeData(), processData(), editing() 

2. Class -> It is blueprint for its objects.
            Logical entity  ->
            Fan  -> speed, weight, no_of_plates, color, model, brand, capacity, price   
                  rotating(), music()
            collection of objects

3. Data Abstraction  ->  Hiding implementation details. Representing only essential things without including background details

4. Encapsulation ->  Binding of data and methods together into a single unit  -> hide the data from outside world

5. Inheritance ->  reuse the code   ->  deriving properties of one object into another

6. Polymorphism  ->   ability to take more than one form.
                     1. compile time  ->  function overloading
                     2, run time -> function overrriding


  class classname
  {
  }

   class Student
   {
        int rollnumber;
        String name;
        int age;
   }



->  classname objectname=new classsanme();

    
Access Sepcifiers -->

1. private  - these will be accessed only within the class
2. public  - these members can be accessed within the class and outside the class
3. protected  - inheritance 
4. default  - these members can be accessed within the class and outside the class but withn the same package only







Employee(id, name, salary)

Create a class Account(accountnumber, accountype, name, balance). Write methods to initialize and display details of 2 accounts.




Create a class Rectangle(width,height). Write methods to initialize and display a rectangle. also write a method to calculate area of rectangle.





main()
{
   int width=10;
   int height=20;
   Recatngle rectangle=new Rectangle(width,height);
   rectangle.calculate();
 Recatngle rectangle2=new Rectangle(width,height);
}






Stack and Heap Memory  -> 


Stack Memory->
1. Temporrary Memory allocation
2. local variables, methods, references

Heap Memory ->
1. Permanaent 
2. Objects are allocated memory inside it




Getters and Setters  -> 



Constants in java  ->  

final int var1;

var1=20;  // error


int var;  // declaration
var=10;  // initialization


Student student=new Student();   /// creating an object

student.setRollNumber(10);      // initialization
student.setName("abc");
student.setAge(25);

int var=10;  


Constructor ->  a special member method of a class
               -> it has same name as that of class
               -> it does not have any return type
               -> it initializes object at the time its creation
               -> it gets invoked automatically when object of a class is created

-> declare constrcuctors as public


class Point
{
    private int x;
    private int y;
  
   Point()
   {
     x=0;
     y=0;
   }

   void display()
   {
      System.out.println("("+x + ","+y+")");
   }

} 



Point point=new Point();
point.display();

--> we can have more than one constructors for a single class   ->  constructor overloading

Types of constructor  -> 
1. Default Contructor  - which does not have any parameters/arguments.
                         if we do not include/write any constructor inside a class then java provides us the one which is a default constructor
2. Parameterized Constructor - which have some parameters/arguments



it is good practice to write default constructor when you have a parameterized constructor



this  ->  it always refers to an object which has currently called a method



Constructor chaining  -> calling one constructor of a class from within another constructor.

x+yi 

5+3i
+
6+4i

11+7i

1. Create a class Complex(real, imaginary). Add default and parameterized constructor. Add getters and setters.
                        create a method for addition of two complex numbers


Integer a=10;


int b=20;

Integer c=b;



Gargabe Collection ->  the object which do not have any reference, java removes such objects automatically, 
                       removing unused objects
                       reclaimin the memory.

           finalization ->   protected void finalize()
                             {
                                   // closing activites
                             }



System.gc()

1. constructor chaining
2. pass by reference
3. garabage collection



Enums  ->   

Array of objects  -> 

int array[]=new int[10];


Student students[]=new Student[30];  // memory for an array of students

student[0]=new Student(1,"abc","swap.kul29@gmail.com");
student[1]=new Student(2,"xyz","xyz@gmail.com");


	    s1	       s2		s3		null	
students    0		1		2		3		4		5		29



Student(rolnumber, name, age, emailid). constructors, getters, setters.   create an array of n students and print it.





Object Calisthenics  --->   we should write clean code




DRY  ->   Do Not Repeat Yourself



JAR  ->>>>    Java Archieve File which encompasses all java code file,and metadata files images, audio,animations, assets

            -> manifest file -> it contains metadata of your jar

jar cf jarfilename inputfiles.


Git & Github  ->   

 Version Control systems  -> to keep track of code changes, who has made changes, coding collaberarions.
                            
                    v1    ->   v2  ->   v3   ->  v4

  ->  bitbucket,  hlix core, mercurial , cvs, git



local repository / remote repository

1.  git --version
2.  git config --global user.name "swapnil"
3. git config --global user.email "swapnilkulkarni498@gmail.com"
4. git config user.name
5. git config user.email
6. git init
7. git add "name.txt"  /    git add --all  /   git add -A  / git add .
8. git rm --cached "name.txt"
9. git commit -m "message"
10. git reset  

12. git log
13. git reflog
14. git branch
15. git branch "branchname"
16. git checkout branchname
17 git switch branchname
18 git merge branchname



Remote repository  ->  github     ->   online repo


1. create a repository

2. git remote add origin url

3. git remote rm origin

4. git branch -M nameofbranch

5. git push origin nameofbranch



Reflection   ->   




Static   ->>>>>>>>>>>>>>>  

1. static class
2. static data members
3. static methods
4. static blocks


static data memebrs   ->   


1. they are property of class , not object
2. they can be used before creation of object
3. they are allocated memory only once when the class is loaded and shared amongst all objects
4. their values  persist thoughout the application 



---->  Create a class Account(accountNumber, name, balance).  Write a code to keep track of how many accounts are being created.

       Account 1 is created

      Account 2 is created

     Account 3 is created  

     Toatl accounts created : 3

static method- >   


1. it can access only static data
2. they are called/invoked using name of class, not object



---> public static void main(String args[])   --->>>

     1. public ->  so that it should be able to get invked from outside the class
     2. static  ->  because it should be able o get invloked without creatign object of the class which contains it
     3. void  ->  it does not return anything


3. static blocks  ->  {}





Inheritance  ->  derives properties of one object into another.
                 Reuse the code

extends   ->>>

class A     ->  super class
{

}

class B exends A    -> sub class
{
}


Types of inheritance  ->

1. single  ->   A   ->>   B    Class B extends A
   
2. multiple  ->  A     B     ---->   C   // not allowed  class C extends A,B

3. mulilevel  ->  A   ->>   B    -->  C    class C  extends B      class B extends  A 

4. hierarachical   ->     A    ->>  B    C

5. hybrid  ->  


->>  private mebers are not inherited





1. Create a class Account(accno,name,balance). Add credit(amount) and debit(amount) methods. Create two subclasses from it - CurrentAccount(OVER_DRAFT_LIMIT) and SavingsAccount(MIN_BALANCE) . Display details of Current and savings account. Validate overdraft limit and min balance requirements. Use getters and setters.  Create Savings and current account objects and test.

2. Create a class Vehicle(companyname). Create a subclass FourWheeler(mileage) from it. Again create a subclass Car(price) from FourWheeler. Write java code to display details of n cars. Use getters and setters.


POC on -> 
1. Serialization & Deserialization.
2. Serialization & Deserialization of array of objects"



Select Account Type :
1. Savings 
2. Current
3. Exit
Enter Your choice: 1
1. Create Account
2. Account Details
3. Credit
4. Debit
5. Exit
Enter Your choice: 1
1. Create Account
2. Account Details
3. Credit
4. Debit
5. Exit
Enter Your choice: 2
1. Create Account
2. Account Details
3. Credit
4. Debit
5. Exit
Enter Your choice: 3
Select Account Type :
1. Savings 
2. Current
3. Exit
Enter Your choice:3

Constructors in inheritance: 

it is responsibility of sub class to initialize its own data memebrs as well as data members of its super class




super  ->

1. super is used to call a superclass constructor from within sub class constructor

     - it must be first statement within sub class constructor


2. super is used to access members of suer class within subclass




note ->   constructors always executes in the order of their derivation


x   ->   y   ->   Z   


Method overriding->   when subclass and superclass have same methods having same name and sam signature(parameters)

 Subclass object always invokes subclass version of overriden method 



A superclass reference can refer to an object of its subclass but it can access only those memebrs which are inherited from superclass to subclass.
it can not access members which are part of subclass only.




Runtime polymorphism  -> Which version of overriden method to call is decided at run time. 
                         it is not type of object that decide which version of overriden method to call, rather it is object to which reference is                          referring to at runtime.
                         



Abstract Method: it is amethod declared inside superlclass which does not have body(definition), 

Abstract Class  - any class having an abstract method must be declared as abstract. 
it is responsibility of its subclasses to give definition to all abstract methods declred inside abstract class.
You can not create object of abstract class

It makes method overrding compulsory



Abstract class can contain non abstract methods too.



inheritance is called as 'is a' relationship

-> Generalization
-> Specialization



final ->   
1. Your methods inside the class should not be oveerrriden in the subclassses (to stop method overrding)
2. to stop inheritance



public abstract final void display();



abstract class X
{
   public abstract void display();
}

abstract class Y extends X
{
   /*void display()
   {
   }*/
}

class Z extends Y
{
   void display(){}
}




protected  ->  
					private		public		protected	default

same class				yes		yes		yes		yes

non subclass in same package		no		yes		yes		yes

sub class in same package		no		yes		yes		yes
	
subclass in other package		no		yes		yes		no

non sublcass in other package		no 		yes		no		no


---> 
in java, multiple inheritance is not allowed  -> we can create a subclass by extending more than one super classes


class A
{
   int a=10;
   void method()
   {
       System.out.println("A);
   }
}

class B
{
   int a=20;
    void method()
   {
       System.out.println("B");
   }
}

class C extends A,B  // not allowed
{
   
}

c.a=30;
c.method();

Abstract class  ->   

Interface   ->   it is like a class that contains methods without body(definition)/ abstract and its data members are static and final


interface A
{
    void method();
    int a=10;
}

interface B
{
   void method();
   int a=20;
}




class C implements A,B
{
   void method(){}
}

c.method();
c.a=30;


A		B       			C

method()	method()




interface A
{
  void display1();

}

interface B extends A
{
   void display2();

}


class C implements B
{

   void display1()
  {
  }

   void display2()
   {
   }

}

// We can not create an object of interface

//  An interface reference can refer to any object of classes that implements that interface.






interface Demo
{

}


class ClassDemo implemets Demo
{

}

class C
{
}

Demo demo=new ClassDemo();
Demo demo=new C();  // not allowed


// loosely coupled


Nested and inner classes   ->>>>>



Object class ->>>>> a parent class of all other classes in java.   

                      Methods of Object class   ->>>>>








Number number1=new Number(10);
Number number2=new Number(10);


System.out.println(number1==number2);
System.out.println(number1.equals(number2));




Exception Handling   ->


Exception  ->   it is an unusual/abnormal condition that arises at runtime/  error that arrives at runtime.


1. try    ->   code where exception is expected
2. catch   ->  code that handle exception 
3. throw
4. throws
5. finally   ->  it is block that exceutes everytime. exception arises or not


------------------------------
-------------------------------
try
{
  ---------------------------
----------------------------
----------------------------
-----------------------------
}
catch()
{
---------------------------------
--------------------------------
--------------------------------

}
-----------------------------
----------------------------
------------------------------


---> for try block you must write catch block or finally


try
{
}
catch()
{
}
catch()
{}
finally
{
}




try
{
}
finaly
{
}
---> for one try block you can write more than one catch blocks



Object

Throwable

Error        Exception

            RuntimeException



Checked Exeptions  -> these are the exceptions that you must handle  ex. ClassNotFoundException, FileNotFoundException
Unchecked Exceptions   ->  there is no compulsion of handling these exceptions  ex. ArtithmeticException, NullPointerException etc.


throw ->  it is used to throw an exception explicitly

throws  -> it is used to specify possible exceptions in a method 


Custom Exceptions  ->   exceptions created by user



--> by extending RuntimeException class


Collections in java  ---->   


Disadvantages of array->

1. Array size is fixed
             int array[]=new int[10];
2. Array cant grow or shrink at runtime
3. Array requires a contigous memory block

           Student students[]=new Student[10];




Collections are used to manage a group of objects in very efficient way.

Collection framework --->  java.util
1. interfaces
2. Classes
3. methods


Iterable   -   Collection   -   1. List     2. Queue   3. Set


1. List  ->  lists a group of objects.
             All objects are managed or accessed with the help of index.
             List can contain duplicate elemennts
   a. ArrayList  ->  dynamic array
   b. LinkedList  -->  doubly linked list  
   c. Vector
   d. Stack

Iterator  ->  we can access elements of collection in forward direction only



ListIterator  -> we can access elements of collection in forward direction as well as backword direction

3. Set ->  objects are not managed or accessed with the help of index.
             Set always contains unique elemennts

  1. HashSet  -> it does not maintain any ordering of elements. 
                 Hashing  ->  hash address  -> 

             1011		abc
             1003		xyz
	     1021		lmn 
  2. LinkedHashSet   ->  maitain insertion ordering of elements
  3. TreeSet ->  maintains sorted order of elements 



4. Map  ->   it is a collection of entries
             An entry is pair of key and value associated with it

             Map always acontains unique entries where value can be repeated but key is always unique

               Rollno		Name
		1		Shankar
		2		Shiva
		3 		Suyash
                4		Shankar
		5		Shankar

   1. HashMap   ->  it does not maitain any order
   2. LinkedHashMap   ->  maitains insertion order
   3. TreeMap  -> maintains sorted order according key

        Map.Entry



--> Comparator  -> 


compare()  ->>>  positive  ->  o1 > o2
                      0     -> o1==o2
                 negative   -> o1 < o2



InsurancePolicy(policyNumber, plolicyHolderName, policyAmount, policyCreationDate). create constructors and getter setters.
Create an arraylist of n policies. Create a menu driven code to sort ploicies accosrding to name, amount and creationdate.

---> How many policies : 5
---->  Enter details of 5 policies

1. Sort by Name
2. Sort by Amount
3. Sort by Creation date
4. exit
Enter tour choice: 1



----->  Multitasking ->   

1. Process Based  ->  Program in execution
                        memory and time
                       
2. Thread Based   ->  Smallest individual part of a process that can run simultaniously.

      ---> not to have your cpu idle 


Thread Life cycle is  ->   


1. new/born  ->   new Thread()
2. Runnable(eligible to run)  ->   start()  
3. Running  ->  run()
4. Blocked (not running) ->  sleep()/ wait()
5. Dead  -> stop()

[main,5,main]   -> Name of thread    Thread Priority   Thread Group



main thread  -> 1. it is always a first thread that runs
                2. All other threads are spawned from this thread
                3. it is often a last thread that finishes its exeution


Creating threads  ->  

1. extending Thread

   class MyThread extends Thread
   {
   }
2. implements Runnable

   class MyThread implements Runnable
   {
   }

  run()
  {
  }


Thread Priority  ->  it is number between 1 to 10

                      1  -> lowest priority
                      10  ->  highest priority

    Priority defines how much cpu time thread will get
    highest prority thread gets maximum cpu time compared to lowest priority thread

  default priority  ->  5

   setPriority(10)

 MAX_PRIORITY  ->  10
 MIN_PRIORITY  ->  1
 NORM_PRIORITY  -> 5

t1 ->  3
t2  -> 9



Agile Scrum   ->

1. Scrum Roles
2. Scrum Artifact
3. Scrum events
4. Scrum Metrics 

Real world use cases  - 20 mins



1.  Agrah & Neelanjana   -> 
2.  Pradeep & Manvendra
3.  Shankar, Deepak & Pratik
4.  Simran and Suyash
5.  Ajay and Sai
6.  Aman and Shiva
7.  Varish and Harshini





join()

t1.join()



asynchronous  ->   
synchonized  ->  


1.synchronized method
2. synchronized block




Interthread communication 


ExecutorService framework  ->  powerful framework to manage and control the execution of tasks in multihreaded way

                               concurrent way of executing the tasks 

                     Thead Pool



1. Cpu intensive ->   
2. i/o intensive


types of thread pools->

1. FixedThreadPool
2. CachedThreadPool  -> 
3. ScheduledThreadPool  ->  
4. SingleThreadExecutor  -> 


    
Callable  -> call()

Future


Features of java8  ->  


1. default methods inside interface
2. static methods inside interface


3. functional interface ->  that has only one abstract method
                            can contain more than one static and default methods

    Marker Interface  ->  Serilizable   -> which does not have any abstract method

4. lamdas

annonymous inner class  ->  inner class without name



IFactorial ->  int fact(int)


Types of functional interfaces ->  

1. Consumer      -->  contains a method which can accept only one argument and does not return anything
   BiConsumer   ->>  contains a method which can accept two arguments and does not return anything
             accept()
2. Supplier   ->   contains a method which does accept any argument and return something
              get()
3. Predicate    ->   contains a method which accept one argument and returns boolean
-->  BiPredicate   -> contains a method which accept two arguments and returns boolean
                test()

    Create a predicate that accepts an email id and return true if it is in valid format ..

       admin@gmail.com

4. Function      --->  BiFunction  ,   UnaryOperator,  BinaryOperator

-->  passing static method as parameter
--> constructor as parameter 


2024-20-06


5. stream api  ->    java.util.stream
                     sequence of elements from a source through pipeline of computations

  list  -> [1,2,4,5,6]      ->      stream     ->>    [11,12,14,15,16]
  set
  array



---> stream is functional in nature  -> operations performed on stream does not modify the original contents of soursce
---> stream is lazy   - evaluates code on demand



Intermediate 				Terminal

does not give end results		gives end results

they returns streams                 returns non stream values

map()					forEach(), reduce(), collect(), max(), min(), anyMatch(), allMatch()
filter()
sorted()


1.flatMap   -> collection of collections



OOAD  ->  Object Oriented Analysis & Design


1. SOLID Principles      --->>


1. S  - SRP -  Single Responsibility Principle   - one class should have one responsibility.. one class should have only one reson to change
2. O  - OCP -Open for Extension & Closed for Change
3. L  - LSP -- Liskov Substitution Principle  --->  your subclass should be able to replace superclass compeletely
4. I  - ISP - Intreface Segregation Principle   --->  You should design interfaces in such a way that any class which is implementing it should be able to implement it fully.  If this is not the case, then you should segregate the interface accordingly.
5. D  - DIP - Dependency inversion Principle   ->  you should avoid direct dependancy.. yu should transfer dependencies



Invoice  -  

id
description
amount 
tax

constructor
getter setters

TaxCalculator
- Invoice invoice

calculateTax()


InvoicePrinter

- Invoice invoice 
printInvoice()


InoiveTest

1. Inheritance   -> Generalization / Specialization  ->  'is a'
2. Association 

   a. Aggregation  ->  (has a) College   ->  Department
   b. Composition -> (part of) both entitis are dependant on each other

                   Vehicle -  Engine
                   Engine





Class Base
{
   void display()
   {
       System.out.println("Base");
   }
}

class Derived extends Base
{
   void display()
   {
      System.out.println("Derived");
   }
   void display2()
   {
     System.out.println("Derived2");
   }
}


Base base=new Derived();

base.display();
base.display2();   // error




Design Patterns   --->

1. Creational   ->>  how objects must be created
2. Structral ->> how structure of classes and interfaces must be
3. Behavioural ->> how communication/intercation between objects must be


1. Creational    ->
  a. Singleton Design Pattern  -->  only one object of a class to create
         i. make constructor as private
         ii. create instance of same class in that class
         ii. give a public access point to that object

 b. Factory Design Pattern  ->  loosely coupled
         Define an iterface or abstract class for creating an object but let the subclasses decide which class to instantiate




ICar  ->  start()   stop()

classes that implements Icar ->

Maruti
Tata
Mahindra


Test class  -->




IAccount  ->  credit(amount)   debit(amount) 

SavingsAccount ->  accno, name, balance

CurrentAccount  ->  accno, overdraft


Implement factory design pattern with menu driven code



2. Strutural Design Patterns  -->  how a structure of objects and classes must be

       a. facade design pattern   ->>
       b. Adapter Design Pattern   --->>











